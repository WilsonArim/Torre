diff --git a/torre-llm/README.md b/torre-llm/README.md
index c0ffee1..9bad0c0 100644
--- a/torre-llm/README.md
+++ b/torre-llm/README.md
@@ -1,26 +1,49 @@
 # LLM-Engenheira — PoC
 
 Loop: coletar erros → gerar **um** patch mínimo → `validate` → `dry_run` → `apply` → métricas.
 
 ## Requisitos
 - Python 3.10+
 
 ## Executar
 ```bash
 python -m torre-llm.orchestrator
 ```
 
 Variáveis (opcional):
 - `TORRE_API_BASE` (default: `http://localhost:8000`)
- `TORRE_WS` (default: `default`)
 - `REPO_ROOT` (default: `.`)
 
 ## Estrutura
 - `orchestrator.py` — ciclo principal
 - `adapters/` — `run_lint`, `run_tests`, `run_build`
 - `strategies/` — `playbook_simple.py` (patch mínimo)
 - `utils/diff_utils.py` — helpers para diff unificado
 - `client.py` — chamadas ao endpoint de ingest/estado
+
+## Modo Offline (sem API)
+Se não tiveres o servidor a correr, usa o runner offline. Ele **simula** `validate/dry_run/apply`, grava o diff em disco e imprime métricas JSON.
+
+```bash
+python -m torre-llm.run_offline
+```
+
+Saída (por defeito):
+- Patches: `.torre/outbox/patch-<mode>-<YYYYMMDD-HHMMSS>.diff`
+- Métricas: JSON no stdout
+
+> Nota: O runner offline **não** aplica o patch no repo; guarda-o para revisão/aplicação manual.
diff --git a/torre-llm/run_offline.py b/torre-llm/run_offline.py
new file mode 100644
index 0000000..d00df00
--- /dev/null
+++ b/torre-llm/run_offline.py
@@ -0,0 +1,92 @@
+"""
+Runner OFFLINE para a LLM-Engenheira.
+Simula validate/dry_run/apply e grava os diffs em .torre/outbox/.
+Não altera o comportamento do orquestrador normal (com API).
+"""
+from __future__ import annotations
+import json
+import sys
+from pathlib import Path
+from datetime import datetime
+
+# Importa o orquestrador depois de definirmos helpers locais.
+from . import orchestrator as orch
+
+OUTBOX = Path(".torre/outbox")
+OUTBOX.mkdir(parents=True, exist_ok=True)
+
+_last_payload: str | None = None
+
+def _ts() -> str:
+    return datetime.now().strftime("%Y%m%d-%H%M%S")
+
+def offline_ingest_report(ws: str, mode: str, payload: str, content_type: str = "text/plain") -> bool:
+    """
+    Simula o endpoint de ingest:
+    * Grava o payload (diff) em .torre/outbox/patch-<mode>-<timestamp>.diff
+    * Retorna True para que o orquestrador continue o fluxo (validate/dry_run/apply)
+    """
+    global _last_payload
+    _last_payload = payload
+    fname = OUTBOX / f"patch-{mode}-{_ts()}.diff"
+    # Garante texto (o orquestrador envia text/plain)
+    data = payload if isinstance(payload, str) else json.dumps(payload, ensure_ascii=False)
+    fname.write_text(data, encoding="utf-8")
+    return True
+
+def offline_get_pipeline_state(ws: str):
+    return {"workspace": ws, "mode": "offline", "state": "unknown"}
+
+def offline_write_pipeline_state(state):
+    p = Path(".torre")
+    p.mkdir(exist_ok=True)
+    (p / "pipeline_state.json").write_text(json.dumps(state, ensure_ascii=False, indent=2), encoding="utf-8")
+
+def main() -> None:
+    # Injeção (monkeypatch) das funções usadas pelo orquestrador
+    orch.ingest_report = offline_ingest_report  # type: ignore[attr-defined]
+    orch.get_pipeline_state = offline_get_pipeline_state  # type: ignore[attr-defined]
+    orch.write_pipeline_state = offline_write_pipeline_state  # type: ignore[attr-defined]
+    
+    try:
+        orch.main()
+    except Exception as e:
+        # Produz JSON de erro para consumo pelo pipeline
+        print(json.dumps({"offline": True, "error": str(e)}))
+        sys.exit(1)
+
+if __name__ == "__main__":
+    main()
